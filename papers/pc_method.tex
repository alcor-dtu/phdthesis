\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{xifthen}
\usepackage{hyperref}

\begin{document} 
\newcommand{\vecfunc}[2] {\vec{#1}(\mathbf{#2})}
\newcommand{\func}[2] {{#1}(\mathbf{#2})}
\newcommand{\omegafunc}[2] {{#1}(\mathbf{#2}, \vec{\omega})}

\newcommand{\xvecfunc}[1] {\vecfunc{#1}{x}}
\newcommand{\xfunc}[1] {\func{#1}{x}}
\newcommand{\xomegafunc}[1] {\omegafunc{#1}{x}}
\newcommand{\nablavec} {{\nabla}}
\newcommand{\omegavec} {\vec{\omega}}
\newcommand{\sphere}[2] {\int_{4\pi}{#1}\ d{\ifthenelse{\isempty{#2}{}}{{\omega}}{#2}}}
\newcommand{\hemisphere}[2] {\int_{2\pi_+}{#1}\ d{\ifthenelse{\isempty{#2}{}}{{\omega}}{#2}}}
\newcommand{\inwardhemisphere}[2] {\int_{2\pi_-}{#1}\ d{\ifthenelse{\isempty{#2}{}}{{\omega}}{#2}}}

\newcommand{\absorption}{\sigma_a}
\newcommand{\transmission}{\sigma_{tr}}
\newcommand{\scattering}{\sigma_s}
\newcommand{\extinction}{\sigma_t}
\newcommand{\fluence}{G_0}
\newcommand{\flux}{\mathbf{G}_1}
\newcommand{\sourcezero}[1]{\func{q}{#1}}
\newcommand{\sourcezerox}{\xfunc{q}}
\newcommand{\sourceone}[1]{\vec{\mathbf{Q}}(\mathbf{#1}, \omegavec)}
\newcommand{\sourceonex}{\vec{\mathbf{Q}}(\mathbf{x}, \omegavec)}
\newcommand{\redsca}{{\sigma}'_s}
\newcommand{\redext}{{\sigma}'_t}
\newcommand{\redscaEddington}{\tilde{\sigma}_s}
\newcommand{\redextEddington}{\tilde{\sigma}_t}
\newcommand{\de}{\text{d}}
\newcommand{\cphi}{C_{\phi}}
\newcommand{\cE}{C_{\mathbf{E}}}

\section*{Point cloud method for rendering BSSRDF}

This is a short note on rendering a triangular mesh onto which we apply a BSSRDF model. The method works on arbitrary static triangular meshes and is unbiased.

We first define some quantities relative to our mesh. We consider a triangle mesh a set $M = \{T_i, i \in [0, N_\Delta - 1] \}$ composed of $N_{\Delta}$ triangles. Each triangle $T_i$ is composed of three vertices:
$$
T_i = \{ \mathbf{v}^i_0, \mathbf{v}^i_1, \mathbf{v}^i_2 \}
$$
From these quantities it straightforward to define two derived quantities, the normal $\vec{n}_i$ and the area $A_i$ of the triangle. 
$$
\vec{n}_i = \frac{(\mathbf{v}^i_1 - \mathbf{v}^i_0) \times (\mathbf{v}^i_2 - \mathbf{v}^i_0) }{ \|(\mathbf{v}^i_1 - \mathbf{v}^i_0) \times (\mathbf{v}^i_2 - \mathbf{v}^i_0)  \|}
$$
$$
A_i = \frac{1}{2} \|(\mathbf{v}^i_1 - \mathbf{v}^i_0) \times (\mathbf{v}^i_2 - \mathbf{v}^i_0) \|
$$
Once we have defined our triangles, we can start describing out our solution. 

Theoretically, we solve the standard rendering equation for BSSRDFs:
\begin{equation*}
L(\mathbf{x}_o, \vec{\omega}_o) = \int_A \int_\Omega S(\mathbf{x}_i, \vec{\omega}_i, \mathbf{x}_o, \vec{\omega}_o) L_i(\mathbf{x}_i, \vec{\omega}_i) (\vec{n}_i \cdot \vec{\omega}_i) d A_i d \vec{\omega}_i 
\end{equation*}
We now solve the integral with Monte Carlo integration with importance sampling. We take $K$ samples from the area integral and one sample from the directional integral:
\begin{equation}
\label{eq:mc}
\begin{split}
L(\mathbf{x}_o, \vec{\omega}_o) &\approx \sum_{k = 1}^K \frac{S(\mathbf{x}_k, \vec{\omega}_k, \mathbf{x}_o, \vec{\omega}_o) L_i(\mathbf{x}_k, \vec{\omega}_k) (\vec{n}_k \cdot \vec{\omega}_k)}{\text{pdf}(\vec{\omega}_k) \text{pdf}(A_k)} = \\
&=  \sum_{k = 1}^K S(\mathbf{x}_k, \vec{\omega}_k, \mathbf{x}_o, \vec{\omega}_o) \Phi_{i,k}(\mathbf{x}_k, \vec{\omega}_k)
\end{split}
\end{equation}

The algorithm is composed of two phases. In the first phase, we generate the $K$ samples on the surface of the model, storing for each position $\mathbf{x}_k$, direction $\vec{\omega}_k$ and incoming flux $\Phi_{i,k}$. In the second phase, we render the final image evaluating the contribution at each pixel.

In phase one, we produce $K$ samples. The $k$-th  sample is composed of a position $\mathbf{x}_k$, a direction $\vec{\omega}_k$ and a flux $\Phi_{i,k}$. First, we choose a triangle $T_j$. We choose the triangle uniformly, so given a random number $\xi \in [0,1)$, $j = \left \lfloor{\xi N_\Delta}\right \rfloor$. To get $\mathbf{x}_k$, we sample a point uniformly on the triangle $T_j$:
$$
\mathbf{x}_k = (1 - \sqrt{\xi_0})\mathbf{v}^j_0 + (1 - {\xi_1})  \sqrt{\xi_0} \mathbf{v}^j_1 +  \xi_1\sqrt{\xi_0} \mathbf{v}^j_2
$$ 
Where $\xi_0, \xi_1 \in [0,1)$. 

Now, the sampling direction $\vec{\omega}_k$ and the flux $\Phi_{i,k}$ need to be evaluated. We leave the choice of the sampling distribution for $\vec{\omega}_k$ to implementation, since it is not important for the method. From sampling the light source we obtain $\vec{\omega}_k$ and an irradiance $E_k$:
$$
E_k(\mathbf{x}_k, \vec{\omega}_k) = \frac{L_i(\mathbf{x}_k, \vec{\omega}_k) (\vec{n}_k \cdot \vec{\omega}_k)}{\text{pdf}(\vec{\omega}_k)}
$$
We need the pdf of the area $\text{pdf}(A_k)$. Since we sampled the triangle and then the point, we combine the two independent probabilities:
$$
\text{pdf}(A_k) = \text{pdf}(T_k) \text{pdf}(\mathbf{x}_k) = \frac{1}{N_\Delta A_j} 
$$
Putting it all together:
$$
\Phi_{i,k}(\mathbf{x}_k, \vec{\omega}_k)  = \frac{E_k(\mathbf{x}_k, \vec{\omega}_k) }{\text{pdf}(A_k)} = N_\Delta A_j E_k(\mathbf{x}_k, \vec{\omega}_k)
$$
Once we have stored this quantity in the sample, we are ready to proceed to the second and final phase. For each pixel, we ray trace a camera ray, obtaining a point $\mathbf{x}_o$ and a direction towards the camera $\vec{\omega}_o$. We consider the scattering medium with coefficients $\sigma_a, \sigma_s, g$ and relative index of refraction $\eta$ as a pure Fresnel interface with added scattering. 

In our path tracing implementation, we perform russian roulette on the Fresnel coefficient $R$ to choose reflected or refracted direction. In the case of reflection, we continue tracing the reflected ray. In the case of refraction, we calculate the final radiance as:
$$
L_o(\mathbf{x}_o, \vec{\omega}_o) = L_e(\mathbf{x}_o, \vec{\omega}_o) + L_t(\mathbf{x}_o, \vec{\omega}_o) + L(\mathbf{x}_o, \vec{\omega}_o) 
$$
Where $L_e$ is the emitted radiance from the medium, $L_t$ is the radiance due to direct transmission and $L$ comes from \ref{eq:mc}. 

To efficiently render the model and save expensive BSSRDF evaluations, we do a last optimization. We evaluate the BSSRDF stochastically with probability $\exp(-\sigma_{tr} \| \mathbf{x}_o - \mathbf{x}_k \|)$, where $\sigma_{tr} = \sqrt{3 \sigma_a (\sigma_a + (1-g) \sigma_s)} $ is the effective transport coefficient.  So, only samples that are very close to the exit point $\mathbf{x}_o$ will be actually evaluated. In formulas:
\begin{equation*}
L(\mathbf{x}_o, \vec{\omega}_o) \approx  \sum_{k = 1}^K S(\mathbf{x}_k, \vec{\omega}_k, \mathbf{x}_o, \vec{\omega}_o) \Phi_{i,k}(\mathbf{x}_k, \vec{\omega}_k) V(\xi, e^{-\sigma_{tr} \| \mathbf{x}_o - \mathbf{x}_k \|})\; e^{\sigma_{tr} \| \mathbf{x}_o - \mathbf{x}_k \|}
\end{equation*}
Where:
$$
V(\xi, d) = \begin{cases}
1 & \text{if} \ \xi < d \\
0 & \text{otherwise}
\end{cases}
$$
In case of a spectral RGB rendering, we pick $\sigma_{tr}$ as the mean of the three rgb components. 


\end{document}